Matklad's most recent talk [Building Systems, Simply](https://www.youtube.com/watch?v=jVC4DP-8xLM&list=WL&index=36&t=11s) was really eye opening and inspiring for me. I'm a young developer with almost no real-world professional experience, but I still like to read a lot of opinions, articles and blogs about programming, programming history and software engineering practices.

A recent trend among things I've read is the idea that complexity is something that should be avoided as much as possible, that software engineering practices have been led astray by "best practices", over-abstractions and a general over complication of things that don't need to be complicated.

Even though I haven't actually encountered the so called [complexity demons](https://grugbrain.dev/#grug-on-complexity) in the wild, I still resonate with this idea that simplicity is paramount to software sustainability, but it's sometimes hard for me to actually judge which is the simple solution and which isn't. Remember, [simple ain't easy](https://www.youtube.com/watch?v=SxdOUGdseq4&t=42s) and if the tradeoffs between simplicity and complexity were always clear-cut we probably wouldn't be in this situation. The reality is that sometimes incidental and inherent complexity are actually really hard to distinguish, specially for someone with less experience.

That's why I enjoyed this talk so much, Matklad gave real-life examples of how this philosophy of simple systems is carried out at [TigerBeetle](https://tigerbeetle.com/) - a financial transaction database written in zig. His first point is about project structure and how making onboarding and day-to-day tasks simple (and fast) makes for a better developer experience:
- The TigerBeetle repository is purposefully kept small and big files (above 1MB) are avoided so that `git clone`s are really fast
- TigerBeetle has only one dependency: the Zig toolchain. On top of that they provide a single unified (polyglot) shellscript for installing the recommended Zig toolchain version inside the repo, avoiding problems associated with package managers, virtual environments and so on.

One thing that struck me was that when he showed TigerBeetle's fuzzer, which always runs on the main branch by simply cloning the repository from scratch everytime(TODO rewatch the video to figure this out), reminded me of how [performance is a feature](https://blog.nelhage.com/post/reflections-on-performance/) and it can unlock new use cases that would never be possible if the operations were slower. (Maybe put this as an aside? A hidden block?)

Another interesting thing is that in general TigerBeetle shies away from anything that isn't zig, since as the saying goes "the right tool for the job is the one you already have". For example, they guard against big files inside the repository by implementing that logic inside a zig[^1] test[^2], not a shell script, not a git hook neither a github action. He goes on to show more things which would generally be done as a shell script/github actions yaml instead be done entirely in zig.

The only places where this is not the case are also very interesting case studies of inherent complexity: The zig toolchain install script, and the multi-platform CI system. For the zig toolchain install script, since you must assume the user doesn't have a zig toolchain available, you're obviously going to need to rely on something else, in this case, shells. But even here, they carefully craft a single polyglot script (so there are no system-specific instructions for developers) that shells out to the actual system dependent scripts.

The other place is on their CI, even though most of their core CI logic is implemented in Zig, setting up machines on multiple different operating systems and versions is something that is inherently complex, and there's no way around that. Here TigerBeetle doesn't look for an in-house solution but uses a tool specifically built for this: Github Actions. They only have one action yaml whose only job is provisioning different architecture/system machines and running their zig code/tests on them.

Most of the content on simplicity and complexity generally repeats the saying that complexity should be avoided unless completely necessary. While I do agree with this statement (and I'd wager most developers do too), the difficult thing is *actually knowing* what is necessary complexity, and what isn't. That's why I really enjoyed his talk, he demonstrated what - him and the TigerBeetle team - considered inherent complexity and what they didn't, and what they actually did about it.


[^1]: Matklad makes it very clear in the talk that this would obviously be better done in something more scripty like shell, Python, Perl, etc. However any one of those would add more complexity to the project: shells are not really portable, so you'd need at least two different versions, one for windows and one for Mac+Linux; Python (and any other interpreted language) is a big dependency to add, specially since it would be only for this use case.

[^2]: This actually led me to wonder, what other checks can we put inside tests? The most obvious ones are code style, formatting, maybe even git message validations! Since the tests are run inside the git repo, we can actually inspect the latest commit for what we want (has to have a description as well as a summary, link to relevant issue, etc. etc.)
