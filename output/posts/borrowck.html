<html><head> <title>'Fighting the Borrow Checker'</title> <link href="../style.css" rel="stylesheet" type="text/css" media="all" <meta charset="UTF-8"> <script type="text/x-mathjax-config"> MathJax.Hub.Config({ tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]} }); </script> <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"> </script> </head> <body><div class="navbar"><a href="../index.html" class="">Home</a><a href="../posts.html" class="active">Posts</a><a href="../notes.html" class="">Notes</a></div><hr>
        <h1>Introduction</h1>
<p>I've been going through Thorsten Ball's <a href="https://craftinginterpreters.com/">Crafting Interpreters</a> and implementing Lox in rust. It's been going great so far, and I'm enjoying doing things in rust, some things are a lot simpler and easier than what he does in C, and I've sprinkled some lifetimes here or there in the codebase to great success. However, I'm having some trouble right now, in trying to implement functions. For some context, Lox is a dinamically typed language, so every value in lox is actually the same Value type, which I've implemented as an enum like so:</p>
<pre><code class="language-rust">pub enum Value {
    Number(f64),
    Bool(bool),
    String(String),
    Nil,
}
</code></pre>
<p>We can see that each value is an enum variant with a payload, which is simple enough. However the real issue starts when we introduce functions, which are also first-class values. Implementing them might seem simple enough, just add another <code>Function(FunStruct)</code> type where <code>FunStruct</code> defines a function, but it's not that simple. The function struct is defined as</p>
<pre><code class="language-rust">pub struct FunctionStruct {
    name: String,
    code: Chunk,
    other_stuff: int32,
}
</code></pre>
<p>where <code>Chunk</code> is a struct which holds the compiled bytecode and associated constants. The problem lies in that a <code>Chunk</code> has a <code>Vec&lt;Value&gt;</code> which means it can hold a <code>FunctionStruct</code> which in turn references some other <code>Chunk</code> or itself. All this to say that, with the current implementation <code>Chunk</code> is now a self-referential struct, which is something notably hard to pull off in rust. I've been trying to brute-force my way into a solution by just fixing compiler errors one by one for days now, but it looks like it's not going anywhere, so I decided to write about the problem and see if that helps.</p>
<h2>Code specifics</h2>
<p>Before looking for a solution, I'll first define how the compiler works as of now, and from there see whether there are some refactors which could solve this. The compiler is pretty simple and has 3 major constructs: <code>Vm</code>, <code>Parser</code> (which is actually a parser + compiler, so from now on I'll refer to it as <code>Compiler</code> in order to make things simpler) and <code>Lexer</code>. <code>Vm</code> is the virtual machine which actually runs the compiled bytecode, and it has a <code>code: Chunk</code> field along with other things it needs to run the code, such as a stack, a hashmap for global variables and a formatter. <code>Compiler</code> and <code>Lexer</code> is where things start to get interesting, their definitions are:</p>
<pre><code class="language-rust">pub struct Compiler&lt;'a&gt; {
    lexer: Lexer&lt;'a&gt;,
    source: &amp;'a str,
    code: &amp;'a mut Chunk,
    rules: HashMap&lt;TokenKind, ParseRule&lt;'a&gt;&gt;,
    scope: Scope&lt;'a&gt;,
}

pub struct Lexer&lt;'a&gt; {
    source: &amp;'a str,
    rest: &amp;'a str,
    offset: usize,
    peeked: Option&lt;Result&lt;Token&lt;'a&gt;, miette::Error&gt;&gt;,
}
</code></pre>
<p>The <code>Lexer</code> contains two references to the source code: one that points to the entire thing, and another that points to the portion of the source code which has not yet been consumed. The <code>peeked</code> field allows tokens to be peeked but not consumed right away, which is needed for lookahead in the compiler. <code>Compiler</code> in turn contains a <code>lexer</code> as well as its own reference to the source code and a <code>Chunk</code> where it's storing the compiled bytecode.</p>
<h1>The Objective</h1>
<p>In the book, functions are implemented in a way where every <code>FunctionStruct</code> object contains a (mutable) reference to its compiled bytecode, and everytime a <code>Compiler</code> encounters a function declaration, a new nested <code>Compiler</code> is instatiated, which then compiles the function body and returns a <code>FunctionStruct</code> value to be stored in the &quot;father&quot; <code>Compiler's</code> constant table. Note that this works for function declarations inside other functions, creating <code>Compilers</code> recursively as needed to compile inner functions. Function calls are much simpler, the parameters are placed on the stack on top of the <code>FunctionStruct</code> value, and when the function call opcode is encountered, the vm simply adds a new <code>CallFrame</code> to the call stack with the <code>FunctionStruct</code> value and execution resumes from there. I would like to be able to implement something very similar to this, in order to have the same semantics as the book's compiler and language.</p>
<h1>Requirements</h1>
<p>So basically what we want is to have a mutable reference to <code>FunctionStruct</code> only when we're compiling its associated function, and after that all we have are immutable references to it, in <code>Chunk</code>, <code>Compiler</code>, <code>CallFrame</code> and the like. <code>FunctionStruct</code> can own its <code>Chunk</code>, and wherever we need a <code>Chunk</code> we can simply have a <code>FunctionStruct</code> instead, which should already resolve the referential-struct situation.</p>
<h1>Just Do It</h1>
<p>After having the requirements clear in my head, I went straight into the codebase changing the plumbing necessary, every <code>Chunk</code> field was replaced with a <code>FunctionStruct</code> field, and some helper methods were implemented to make things easier. Now that the code is working correctly with <code>CallFrame</code>s and <code>FunctionStruct</code>s (with no functions, that is) we can focus on function support for the <code>Compiler</code>.</p>
</body></html>